library neo4darttest;
import 'dart:io';
import 'dart:async';

import 'markdown_configuration.dart';
import 'package:unittest/unittest.dart';
import '../lib/neo4dart.dart';

Neo4Dart neo4d;

main() {

  List path = Platform.script.pathSegments.getRange(0, Platform.script.pathSegments.length-2).fold(new List(), (List list, String segment) => list..add(segment))..add('doc/result.md');
  unittestConfiguration = new MakedownConfiguration(Platform.pathSeparator + path.join(Platform.pathSeparator),
      ['#REST Api compatibility check list  \n',
       '  \n',
       '  \n',
       'This check list is based on the [REST api documentation](http://docs.neo4j.org/chunked/snapshot/rest-api.html) of Neo4j 2.0 snapshot  \n',
       'This file is generated by automated unit-tests  \n',
       '  \n',
       '  \n',
       '  \n',
       '##Results  \n',
       '  \n'
       ]);

  Neo4Dart.init("127.0.0.1").then((Neo4Dart r) {
    neo4d = r;
    transactionnal();
    serviceRoot();
    streaming();
    cypher();
    propertyValues();
    nodes();
    relationShips();
    relationShipTypes();
    nodeProperties();
    relationshipProperties();
    nodeLabels();
    indexing();
    constraints();
    traversals();
    graphAlgo();
    batch();
//    legacyIndexing();
//    uniqueIndexing();
//    legacyAutomaticIndex();
//    configurableLegacyAutomaticIndex();
  });
}


void transactionnal() {
  group('Transactionnal', () {
    test('20.1.1. Begin a transaction', () {
      fail("(Not implemented)");
    });
    test('20.1.2. Execute statements in an open transaction', () {
      fail("(Not implemented)");
    });
    test('20.1.3. Execute statements in an open transaction in REST format for the return', () {
      fail("(Not implemented)");
    });
    test('20.1.4. Reset transaction timeout of an open transaction', () {
      fail("(Not implemented)");
    });
    test('20.1.5. Commit an open transaction', () {
      fail("(Not implemented)");
    });
    test('20.1.6. Rollback an open transaction', () {
      fail("(Not implemented)");
    });
    test('20.1.7. Begin and commit a transaction in one request', () {
      fail("(Not implemented)");
    });
    test('20.1.8. Return results in graph format', () {
      fail("(Not implemented)");
    });
    test('20.1.9. Handling errors', () {
      fail("(Not implemented)");
    });
  });
}

void serviceRoot() {
  group('Service root', () {
    test('20.2.1. Get service root', () {
      fail("(Not implemented)");
    });
  });
}

void streaming() {
  group('Streaming', () {
    test('20.3. Streaming', () {
      fail("(Not implemented)");
    });
  });
}

void cypher() {
  group('Cypher queries', () {
    test('20.4.1. Use parameters', () {
      fail("(Not implemented)");
    });
    test('20.4.2. Create a node', () {
      fail("(Not implemented)");
    });
    test('20.4.3. Create a node with multiple properties', () {
      fail("(Not implemented)");
    });
    test('20.4.4. Create mutiple nodes with properties', () {
      fail("(Not implemented)");
    });
    test('20.4.5. Set all properties on a node using Cypher', () {
      fail("(Not implemented)");
    });
    test('20.4.6. Send a query', () {
      fail("(Not implemented)");
    });
    test('20.4.7. Return paths', () {
      fail("(Not implemented)");
    });
    test('20.4.8. Nested results', () {
      fail("(Not implemented)");
    });
    test('20.4.9. Retrieve query metadata', () {
      fail("(Not implemented)");
    });
    test('20.4.10. Errors', () {
      fail("(Not implemented)");
    });
  });
}

void propertyValues() {
  group('Property values', () {
    test('20.5.1. Arrays', () {
      fail("(Not implemented)");
    });
    test('20.5.2. Property keys', () {
      fail("(Not implemented)");
    });
    test('20.5.3. List all property keys', () {
      fail("(Not implemented)");
    });
  });
}

void nodes() {
  group('Nodes', () {
    Node createdNode;
    test('20.6.1. Create node', () {
      Future f = neo4d.nodes.create();
      f.then((Node node) {
        expect(node, isNotNull);
        expect(node.properties, isNotNull);
        expect(node.properties.length, isZero);
        createdNode = node;
      });
      expect(f, completes);
      return f;
    });
    test('20.6.2. Create node with properties', () {
      Future f = neo4d.nodes.create(properties: {"name": "Eric Taix", "birthday": "1968/11/11"});
      f.then((Node node) {
        expect(node, isNotNull);
        expect(node.properties, isNotNull);
        expect(node.properties.length, isNonZero);
        expect(node.properties['name'], equals('Eric Taix'));
        expect(node.properties['birthday'], equals('1968/11/11'));
      });
      expect(f, completes);
      return f;
    });
    test('20.6.3. Get node', () {
      Future f = neo4d.nodes.get(createdNode.id);
      f.then((Node node) {
        expect(node, isNotNull);
        expect(node.id, equals(createdNode.id));
      });
      expect(f, completes);
      return f;

    });
    test('20.6.4. Get non-existent node', () {
      Future f = neo4d.nodes.get(9999999999);
      f.then((Node node) {
        fail('This node should not exist');
      }, onError: (e) {
        expect(e.statusCode, equals(404));
      });
    });
    test('20.6.5. Delete node', () {
      Future f = neo4d.nodes.delete(createdNode.id);
      expect(f, completes);
    });
    test('20.6.6. Nodes with relationships cannot be deleted', () {
      int id = null;
      Future<Node> start = neo4d.nodes.create();
      Future<Node> end = neo4d.nodes.create();
      Future f = Future.wait([start, end]).then((List<Node> nodes) {
        id = nodes[0].id;
        return nodes[0].relations.create(nodes[1], "blocks_delete");
      }).then((_) {
        return neo4d.nodes.delete(id);
      }).then(((_) {
      })).catchError((e) {
        expect(e.statusCode, equals(409));
      });
      return f;
    });
  });
}

void relationShips() {
  group('Relationships', () {
    test('20.7.1. Get Relationship by ID', () {
      fail("(Not yet implemented)");
    });
    test('20.7.2. Create relationship', () {
      Future f = neo4d.nodes.create();
      f.then((Node node1) {
        expect(node1, isNotNull);
        Future f = neo4d.nodes.create();
        f.then((Node node2) {
          expect(node2, isNotNull);
          Future f = node1.relations.create(node2, "LIKES");
          f.then((RelationShip relation) {
            expect(relation, isNotNull);
            expect(relation.type, equals("LIKES"));
          });
          expect(f, completes);
        });
        expect(f, completes);
      });
      expect(f, completes);
      return f;
    });
    RelationShip rs_20_7_3;
    Node n_20_7_3;
    test('20.7.3. Create a relationship with properties', () {
      Future f = neo4d.nodes.create();
      f.then((Node node1) {
        n_20_7_3 = node1;
        expect(node1, isNotNull);
        Future f = neo4d.nodes.create();
        f.then((Node node2) {
          expect(node2, isNotNull);
          Future f = node1.relations.create(node2, "LIKES", properties: { "foo" : "bar", "hip" : "hop"});
          f.then((RelationShip relation) {
            rs_20_7_3 = relation;
            expect(relation, isNotNull);
            expect(relation.type, equals("LIKES"));
            expect(relation.properties['foo'], equals('bar'));
            expect(relation.properties['hip'], equals('hop'));
            print('${relation.startReference} -> ${relation.endReference}');
          });
          expect(f, completes);
        });
        expect(f, completes);
      });
      expect(f, completes);
      return f;
    });
    test('20.7.4. Delete relationship', () {
      Node n1, n2;
      Future fn1 = neo4d.nodes.create();
      fn1.then((Node n) { n1 = n; });
      Future fn2 = neo4d.nodes.create();
      fn2.then((Node n) { n2 = n; });
      Future fn = Future.wait([fn1, fn2]);
      fn.then((_) {
        Future f = n1.relations.create(n2, 'SELF');
        f.then((RelationShip relation) {
          Future f = relation.delete();
          expect(f, completes);
        });
        expect(f, completes);
      });
      expect(fn, completes);
      return fn;
    });
    test('20.7.5. Get all properties on a relationship', () {
      Future f = rs_20_7_3.getProperties();
      f.then((Map properties) {
        expect(properties, isNotNull);
        expect(properties['foo'], equals('bar'));
        expect(properties['hip'], equals('hop'));
      });
      expect(f, completes);
      return f;
    });
    test('20.7.6. Set all properties on a relationship', () {
      Future f = rs_20_7_3.setProperties({ "name" : "Eric Taix", "birthday" : "1968/11/11"});
      f.then((_) {
        expect(rs_20_7_3.type, equals("LIKES"));
        expect(rs_20_7_3.properties['foo'], isNull);
        expect(rs_20_7_3.properties['hip'], isNull);
        expect(rs_20_7_3.properties['name'], equals('Eric Taix'));
        expect(rs_20_7_3.properties['birthday'], equals('1968/11/11'));
      });
      expect(f, completes);
      return f;
    });
    test('20.7.7. Get single property on a relationship', () {
      Future f = rs_20_7_3.getProperty('name');
      f.then((String value) {
        expect(value, equals('Eric Taix'));
      });
      expect(f, completes);
      return f;
    });
    test('20.7.8. Set single property on a relationship', () {
      Future f = rs_20_7_3.setProperty('name','Eric Taxi');
      f.then((_) {
        expect(rs_20_7_3.properties['name'], equals('Eric Taxi'));
        expect(rs_20_7_3.properties['birthday'], equals('1968/11/11'));
        Future f = rs_20_7_3.getProperty('name');
        f.then((String value) {
          expect(value, equals('Eric Taxi'));
        });
        expect(f, completes);
      });
      expect(f, completes);
      return f;
    });
    Node n1, n2, n3;
    test('20.7.9. Get all relationships', () {
      Future fn1 = neo4d.nodes.create(properties: {'name':'Eric'});
      fn1.then((Node n) { n1 = n; });
      Future fn2 = neo4d.nodes.create(properties: {'name':'Chrystèle'});
      fn2.then((Node n) { n2 = n; });
      Future fn3 = neo4d.nodes.create(properties: {'name':'Edgard'});
      fn3.then((Node n) { n3 = n; });
      Future fn = Future.wait([fn1, fn2, fn3]);
      fn.then((_) {
        Future fr1 = n1.relations.create(n2, 'MARRIED_WITH', properties : {'role' : 'husband'});
        Future fr2 = n1.relations.create(n3, 'PARENT_OF', properties : {'role' : 'father'});
        Future fr3 = n2.relations.create(n3, 'PARENT_OF', properties : {'role' : 'mother'});
        Future fr4 = n2.relations.create(n1, 'MARRIED_WITH', properties : {'role' : 'wife'});
        Future fr = Future.wait([fr1, fr2, fr3, fr4]);
        fr.then((_) {
          Future f = n1.relations.getAll();
          f.then((List<RelationShip> relations) {
            relations.forEach((RelationShip r) {
              if (r.type == 'PARENT_OF') {
                expect(r.properties['role'], equals('father'));
                return;
              }
              if (r.type == 'MARRIED_WITH') {
                if (r.startReference == n1.reference) {
                  expect(r.properties['role'], equals('husband'));
                  return;
                }
                if (r.endReference == n1.reference) {
                  expect(r.properties['role'], equals('wife'));
                  return;
                }
              }
              fail('Wrong relation: ${r}');
            });
            expect(relations, isNotNull);
            expect(relations.length, 3);
          });
          expect(f, completes);
        });
        expect(fr, completes);
      });
      expect(fn, completes);
      return fn;
    });
    test('20.7.10. Get incoming relationships', () {
      Future f = n1.relations.getIncoming();
      f.then((List<RelationShip> relations) {
        expect(relations, isNotNull);
        expect(relations.length, 1);
        expect(relations[0].endReference, equals(n1.reference));
        expect(relations[0].properties['role'], equals('wife'));
      });
      expect(f, completes);
      return f;
    });
    test('20.7.11. Get outgoing relationships', () {
      Future f = n1.relations.getOutgoing();
      f.then((List<RelationShip> relations) {
        expect(relations, isNotNull);
        expect(relations.length, 2);
      });
      expect(f, completes);
      return f;
    });
    test('20.7.12. Get typed relationships', () {
      Node n4, n5;
      Future fn4 = neo4d.nodes.create(properties: {'name':'Arthur'});
      fn4.then((Node n) => n4 = n);
      Future fn5 = neo4d.nodes.create(properties: {'name':'Jules'});
      fn5.then((Node n) => n5 = n);
      Future fn = Future.wait([fn4, fn5]);
      fn.then((_) {
        Future fr4 = n1.relations.create(n4, 'PARENT_OF', properties: {'role':'father'});
        Future fr5 = n1.relations.create(n5, 'PARENT_OF', properties: {'role':'father'});
        Future fr = Future.wait([fr4, fr5]);
        fr.then((_) {
          Future f = n1.relations.getAll(types: ['PARENT_OF']);
          f.then((List<RelationShip> relations) {
            expect(relations, isNotNull);
            expect(relations.length, 3);
          });
          expect(f, completes);
        });
        expect(fr, completes);
      });
      expect(fn, completes);
      return fn;
    });
    test('20.7.13. Get relationships on a node without relationships', () {
      Future f = neo4d.nodes.create(properties: {'name':'ghost'});
      f.then((Node n) {
       Future f =  n.relations.getAll();
       f.then((List<RelationShip> relations) {
          expect(relations, isNotNull);
          expect(relations, isEmpty);
        });
       expect(f, completes);
      });
      expect(f, completes);
      return f;
    });
  });
}

void relationShipTypes() {
  group('Relationship types', () {
    test('20.8.1. Get relationship types', () {
      Future f = neo4d.relationTypes.getTypes();
      f.then((List<String> types) {
        expect(types, isNotNull);
        expect(types.length, isNonZero);
        // Can't expect much more ! We don't the store state...
      });
      expect(f, completes);
      return f;
    });
  });
}

void nodeProperties() {

  group('Node properties', () {
    Node n;
    Future f = neo4d.nodes.create(properties: {'firstname' : 'eric', 'name' : 'taix'});
    f.then((Node r) => n = r);
    //expect(f, completes);
    test('20.9.1. Set property on node', () {
      Future f = n.setProperty('name', 'Taix');
      f.then((_) {
        // Not a real test as it does not test if the new property's value has been stored properly
        expect(n.properties['name'], equals('Taix'));
        Future f = n.getProperties();
        f.then((Map<String, Object> properties) {
          expect(properties, isNotNull);
          expect(properties.length, isNonZero);
          expect(properties['name'], equals('Taix'));
          expect(properties['firstname'], equals('eric'));
          // Now test if we can set a non existing property
          f = n.setProperty('age', 45);
          f.then((_) {
            Future f = n.getProperties();
            f.then((Map<String, Object> properties) {
              expect(properties, isNotNull);
              expect(properties.length, isNonZero);
              expect(properties['name'], equals('Taix'));
              expect(properties['firstname'], equals('eric'));
              expect(properties['age'], equals(45));
            });
            expect(f, completes);
          });
          expect(f, completes);
        });
        expect(f, completes);
      });
      expect(f, completes);
      return f;
    });
    test('20.9.2. Update node properties', () {
      Future f = n.setProperties({'firstname': 'Eric', 'married' : true});
      // We don't care about the result as it doesn't reflect the store's current values
      f.then((_) {
        Future f = n.getProperties();
        f.then((Map<String, Object> properties) {
          expect(properties, isNotNull);
          expect(properties.length, equals(2));
          expect(properties['firstname'], equals('Eric'));
          expect(properties['married'], equals(true));
          expect(properties['name'], isNull);
        });
        expect(f, completes);
      });
      expect(f, completes);
      return f;

    });
    test('20.9.3. Get properties for node', () {
      Future f = n.getProperties();
      f.then((Map<String, Object> properties) {
        expect(properties, isNotNull);
        expect(properties.length, equals(2));
        expect(properties['firstname'], equals('Eric'));
        expect(properties['married'], equals(true));
        expect(properties['name'], isNull);
      });
      expect(f, completes);
      return f;
     });
    test('20.9.4. Property values can not be null', () {
      Future f = n.setProperty('name', null).then((_) {
        fail("Should have failed: property values can not be null");
      }, onError: (RestException e) {
        expect(e.statusCode, 400);
      });
      return f;
    });
    test('20.9.5. Property values can not be nested', () {
      Future f = n.setProperty('name', { "foo" : "bar"});
      f.then((_) {
        fail("Should have failed: Property values can not be nested");
      }, onError: (e) {
        expect(e.statusCode, equals(400));
      });
    });
    test('20.9.6. Delete all properties from node', () {
      Future f = n.removeProperties();
      f.then((_) {
        Future f = n.getProperties();
        f.then((Map<String, Object> properties) {
          expect(properties, isNotNull);
          expect(properties.length, equals(0));
        });
        expect(f, completes);
      });
      expect(f, completes);
      return f;
    });
    test('20.9.7. Delete a named property from a node', () {
      Future f = n.setProperties({'firstname': 'Eric', 'married' : true});
      // We don't care about the result as it doesn't reflect the store's current values
      f.then((_) {
        Future f = n.removeProperty('firstname');
        f.then((_) {
          Future f = n.getProperties();
          f.then((Map<String, Object> properties) {
            expect(properties, isNotNull);
            expect(properties.length, equals(1));
            expect(properties['firstname'], isNull);
            expect(properties['married'], equals(true));
          });
          expect(f, completes);
        });
        expect(f, completes);
      });
      expect(f, completes);
      return f;
    });
  });
}

void relationshipProperties() {
  group('Relationship properties', () {
    Node n1, n2;
    Future f1 = neo4d.nodes.create(properties: {'firstname' : 'eric', 'name' : 'taix'});
    f1.then((Node r) => n1 = r);
    Future f2 = neo4d.nodes.create(properties: {'firstname' : 'eric2', 'name' : 'taix2'});
    f2.then((Node r) => n2 = r);
    Future f = Future.wait([f1,f2]);
    f.then((_) {
      // Don't know if it's a good test for this chapter: it seems to be redundant with 20.9.2
      test('20.10.1. Update relationship properties', () {
        Future f = n1.relations.create(n2, "MARRIED", properties: {'role' : 'husband', 'since' : '1994/07/09'});
        f.then((RelationShip relation) {
          Future f = relation.setProperties({'role' : 'mari', 'years' : 19 });
          f.then((_) {
            Future f = relation.getProperties();
            f.then((Map<String, Object> properties) {
              expect(properties, isNotNull);
              expect(properties.length, 2);
              expect(properties['role'], equals('mari'));
              expect(properties['years'], equals(19));
              expect(properties['since'], isNull);
            });
            expect(f, completes);
          });
          expect(f, completes);
        });
        expect(f, completes);
        return f;
      });
      // Seems to be redundant with 20.9.6
      test('20.10.2. Remove properties from a relationship', () {
        Future f = n1.relations.create(n2, "FRIEND", properties: {'when' : '1990/09/10', 'where' : 'nightclub'});
        f.then((RelationShip relation) {
          Future f = relation.removeProperties();
          f.then((_) {
            Future f = relation.getProperties();
            f.then((Map<String, Object> properties) {
              expect(properties, isNotNull);
              expect(properties.length, 0);
            });
            expect(f, completes);
          });
          expect(f, completes);
        });
        expect(f, completes);
        return f;
      });
      // Seems to be redundant with 20.9.7
      RelationShip relation;
      test('20.10.3. Remove property from a relationship', () {
        Future f = n2.relations.create(n1, "FRIEND", properties: {'when' : '1990/09/10', 'where' : 'nightclub'});
        f.then((RelationShip r) {
          relation = r;
          Future f = relation.removeProperty('where');
          f.then((_) {
            Future f = relation.getProperties();
            f.then((Map<String, Object> properties) {
              expect(properties, isNotNull);
              expect(properties.length, 1);
              expect(properties['when'], equals('1990/09/10'));
              expect(properties['where'], isNull);
            });
            expect(f, completes);
          });
          expect(f, completes);
        });
        expect(f, completes);
        return f;
      });
      test('20.10.4. Remove non-existent property from a relationship', () {
        Future f = relation.removeProperty('ghost');
        f.then((_) {
          fail("Should fail: can't remove a non-existent property");
        }, onError: (RestException e) {
          expect(e.statusCode, 404);
        });
      });
      test('20.10.5. Remove properties from a non-existing relationship', () {
        Future f = n2.relations.create(n2, 'DIRECTED');
        f.then((RelationShip relation) {
          Future f = relation.delete();
          f.then((_) {
            Future f = relation.removeProperties();
            f.then((_) {
              fail("Should fail: can't remove properties from a non-existing relationship");
            }, onError: (RestException e) {
              expect(e.statusCode, 404);
            });
          });
          expect(f, completes);
        });
        expect(f, completes);
        return f;
      });
      test('20.10.6. Remove property from a non-existing relationship', () {
        Future f = n2.relations.create(n2, 'DIRECTED');
        f.then((RelationShip relation) {
          Future f = relation.delete();
          f.then((_) {
            Future f = relation.removeProperty('does_not_matter');
            f.then((_) {
              fail("Should fail: can't remove properties from a non-existing relationship");
            }, onError: (RestException e) {
              expect(e.statusCode, 404);
            });
          });
          expect(f, completes);
        });
        expect(f, completes);
        return f;
      });
    });
  });
}

void nodeLabels() {
  group('Node labels', () {
    Node n;
    Future f = neo4d.nodes.create(properties: {'firstname' : 'eric', 'name' : 'taix'});
    f.then((Node r) => n = r);
    //expect(f, completes);
    test('20.11.1. Adding a label to a node', () {
      Future f = n.labels.add('MANAGER');
      f.then((_) {
        Future f = n.labels.get();
        f.then((List<String> labels) {
           expect(labels, isNotNull);
           expect(labels.length, 1);
           expect(labels[0], equals('MANAGER'));
        });
        expect(f, completes);
      });
      expect(f, completes);
      return f;
    });
    test('20.11.2. Adding multiple labels to a node', () {
      Future f = n.labels.adds(['MUSICIAN', 'PLAYER']);
      f.then((_) {
        Future f = n.labels.get();
        f.then((List<String> labels) {
           expect(labels, isNotNull);
           expect(labels.length, 3);
        });
        expect(f, completes);
      });
      expect(f, completes);
      return f;
    });
    test('20.11.3. Adding a label with an invalid name', () {
      Future f = n.labels.add('');
      f.then((_) {
       fail("Should fail: can't add an empty label");
      }, onError: (RestException e) {
        expect(e.statusCode, 400);
      });
    });
    test('20.11.4. Replacing labels on a node', () {
      Future f = n.labels.set(['ENGINEER', 'COOKER']);
      f.then((_) {
        Future f = n.labels.get();
        f.then((List<String> labels) {
           expect(labels, isNotNull);
           expect(labels.length, 2);
           expect(labels[0], 'ENGINEER');
           expect(labels[1], 'COOKER');
        });
        expect(f, completes);
      });
      expect(f, completes);
      return f;
    });
    test('20.11.5. Removing a label from a node', () {
      Future f = n.labels.remove('COOKER');
      f.then((_) {
        Future f = n.labels.get();
        f.then((List<String> labels) {
           expect(labels, isNotNull);
           expect(labels.length, 1);
           expect(labels[0], 'ENGINEER');
        });
        expect(f, completes);
      });
      expect(f, completes);
      return f;
    });
    test('20.11.6. Listing labels for a node', () {
      Future f = n.labels.get();
      f.then((List<String> labels) {
        expect(labels, isNotNull);
        expect(labels.length, 1);
        expect(labels[0], 'ENGINEER');
      });
      expect(f, completes);
      return f;
    });
    test('20.11.7. Get all nodes with a label', () {
      fail("(Can't be implemented: wait for Neo4J answer)");
    });
    test('20.11.8. Get nodes by label and property', () {
      fail("(Can't be implemented: wait for Neo4J answer)");
    });
    test('20.11.9. List all labels', () {
      fail("(Can't be implemented: wait for Neo4J answer)");
    });
  });
}

void indexing() {
  group('Indexing', () {
    test('20.12.1. Create index', () {
      fail("(Not implemented)");
    });
    test('20.12.2. List indexes for a label', () {
      fail("(Not implemented)");
    });
    test('20.12.3. Drop index', () {
      fail("(Not implemented)");
    });
  });
}

void constraints() {
  group('Constraints', () {
    test('20.13.1. Create uniqueness constraint', () {
      fail("(Not implemented)");
    });
    test('20.13.2. Get a specific uniqueness constraint', () {
      fail("(Not implemented)");
    });
    test('20.13.3. Get all uniqueness constraints for a label', () {
      fail("(Not implemented)");
    });
    test('20.13.4. Get all constraints for a label', () {
      fail("(Not implemented)");
    });
    test('20.13.5. Get all constraints', () {
      fail("(Not implemented)");
    });
    test('20.13.6. Drop constraint', () {
      fail("(Not implemented)");
    });
  });
}

void traversals() {
  group('Traversals', () {
    test('20.14.1. Traversal using a return filter', () {
      fail("(Not implemented)");
    });
    test('20.14.2. Return relationships from a traversal', () {
      fail("(Not implemented)");
    });
    test('20.14.3. Return paths from a traversal', () {
      fail("(Not implemented)");
    });
    test('20.14.4. Traversal returning nodes below a certain depth', () {
      fail("(Not implemented)");
    });
    test('20.14.5. Creating a paged traverser', () {
      fail("(Not implemented)");
    });
    test('20.14.6. Paging through the results of a paged traverser', () {
      fail("(Not implemented)");
    });
    test('20.14.7. Paged traverser page size', () {
      fail("(Not implemented)");
    });
    test('20.14.8. Paged traverser timeout', () {
      fail("(Not implemented)");
    });
  });
}

void graphAlgo() {
  group('Graph Algorithms', () {
    test('20.15.1. Find all shortest paths', () {
      fail("(Not implemented)");
    });
    test('20.15.2. Find one of the shortest paths', () {
      fail("(Not implemented)");
    });
    test('20.15.3. Execute a Dijkstra algorithm and get a single path', () {
      fail("(Not implemented)");
    });
    test('20.15.4. Execute a Dijkstra algorithm with equal weights on relationships', () {
      fail("(Not implemented)");
    });
    test('20.15.5. Execute a Dijkstra algorithm and get multiple paths', () {
      fail("(Not implemented)");
    });
  });
}

void batch() {
  group('Batch operations', () {
    test('20.16.1. Execute multiple operations in batch', () {
      Node n1, n2, n3;
      Batch batch = new Batch();
      neo4d.nodes.create(executor: batch).then((Node n) => n1 = n);
      neo4d.nodes.create(properties : {'name' : 'chrystelle', 'age' : 44}, executor: batch).then((Node n) => n2 = n);
      neo4d.nodes.create(executor: batch).then((Node n) => n3 = n);
      Future f = batch.flush();
      f.then((e) {
        expect(n1, isNotNull);
        expect(n2, isNotNull);
        expect(n3, isNotNull);
        // Add another test to verify if we can use relationships and change node with the same batch
        RelationShip r1;
        Batch batch = new Batch();
        n1.setProperties({'name' : 'eric', 'age' :  45}, executor: batch);
        n2.setProperty('name', 'chrystèle', executor: batch);
        n1.relations.create(n2, 'MARRIED', executor: batch).then((RelationShip r) => r1 = r);
        Future f = batch.flush();
        f.then((_) {
          expect(r1, isNotNull);
          expect(r1.type, equals('MARRIED'));
        });
        expect(f, completes);
      });
      expect(f, completes);
      return f;
    });
    test('20.16.2. Refer to items created earlier in the same batch job', () {
      fail("(Not implemented)");
    });
    test('20.16.3. Execute multiple operations in batch streaming', () {
      fail("(Not implemented)");
    });
  });
}

void legacyIndexing() {
  group('Legacy indexing', () {
    test('20.17.1. Create node index', () {
      fail("(Not implemented)");
    });
    test('20.17.2. Create node index with configuration', () {
      fail("(Not implemented)");
    });
    test('20.17.3. Delete node index', () {
      fail("(Not implemented)");
    });
    test('20.17.4. List node indexes', () {
      fail("(Not implemented)");
    });
    test('20.17.5. Add node to index', () {
      fail("(Not implemented)");
    });
    test('20.17.6. Remove all entries with a given node from an index', () {
      fail("(Not implemented)");
    });
    test('20.17.7. Remove all entries with a given node and key from an index', () {
      fail("(Not implemented)");
    });
    test('20.17.8. Remove all entries with a given node, key and value from an index', () {
      fail("(Not implemented)");
    });
    test('20.17.9. Find node by exact match', () {
      fail("(Not implemented)");
    });
    test('20.17.10. Find node by query', () {
      fail("(Not implemented)");
    });
  });
}

void uniqueIndexing() {
  group('Unique indexing', () {
    test('20.18.1. Get or create unique node (create)', () {
      fail("(Not implemented)");
    });
    test('20.18.2. Get or create unique node (existing)', () {
      fail("(Not implemented)");
    });
    test('20.18.3. Create a unique node or return fail (create)', () {
      fail("(Not implemented)");
    });
    test('20.18.4. Create a unique node or return fail (fail)', () {
      fail("(Not implemented)");
    });
    test('20.18.5. Add an existing node to unique index (not indexed)', () {
      fail("(Not implemented)");
    });
    test('20.18.6. Add an existing node to unique index (already indexed)', () {
      fail("(Not implemented)");
    });
    test('20.18.7. Get or create unique relationship (create)', () {
      fail("(Not implemented)");
    });
    test('20.18.8. Get or create unique relationship (existing)', () {
      fail("(Not implemented)");
    });
    test('220.18.9. Create a unique relationship or return fail (create)', () {
      fail("(Not implemented)");
    });
    test('20.18.10. Create a unique relationship or return fail (fail)', () {
      fail("(Not implemented)");
    });
    test('20.18.11. Add an existing relationship to a unique index (not indexed)', () {
      fail("(Not implemented)");
    });
    test('20.18.12. Add an existing relationship to a unique index (already indexed)', () {
      fail("(Not implemented)");
    });
  });
}

void legacyAutomaticIndex() {
  group('Legacy automatic indexing', () {
    test('20.19.1. Find node by exact match from an automatic index', () {
      fail("(Not implemented)");
    });
    test('20.19.2. Find node by query from an automatic index', () {
      fail("(Not implemented)");
    });
  });
}

void configurableLegacyAutomaticIndex() {
  group('Configurable Legacy automatic indexing', () {
    test('20.20.1. Create an auto index for nodes with specific configuration', () {
      fail("(Not implemented)");
    });
    test('20.20.2. Create an auto index for relationships with specific configuration', () {
      fail("(Not implemented)");
    });
    test('20.20.3. Get current status for autoindexing on nodes', () {
      fail("(Not implemented)");
    });
    test('20.20.4. Enable node autoindexing', () {
      fail("(Not implemented)");
    });
    test('20.20.5. Lookup list of properties being autoindexed', () {
      fail("(Not implemented)");
    });
    test('20.20.6. Add a property for autoindexing on nodes', () {
      fail("(Not implemented)");
    });
    test('20.20.7. Remove a property for autoindexing on nodes', () {
      fail("(Not implemented)");
    });
  });
}
